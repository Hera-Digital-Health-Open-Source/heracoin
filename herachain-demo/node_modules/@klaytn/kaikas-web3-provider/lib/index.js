"use strict";
// Copyright (c) 2018-2022 Coinbase, Inc. <https://www.coinbase.com/>
// Licensed under the Apache License, version 2.0
// This file is derived from coinbase-wallet-sdk/packages/wallet-sdk/src/provider/CoinbaseWalletProvider.ts (2022/08/01).
// Modified for the kaikas-web3-provider development.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.KaikasWeb3Provider = void 0;
const safe_event_emitter_1 = __importDefault(require("@metamask/safe-event-emitter"));
const JSONRPC_1 = require("./JSONRPC");
const eth_rpc_errors_1 = require("eth-rpc-errors");
const caver_js_1 = __importDefault(require("caver-js"));
const SubscriptionManager_1 = require("./SubscriptionManager");
class KaikasWeb3Provider extends safe_event_emitter_1.default {
    constructor(provider) {
        super();
        this._addresses = [];
        this._subscriptionManager = new SubscriptionManager_1.SubscriptionManager(this);
        this._send = this.send.bind(this);
        this._sendAsync = this.sendAsync.bind(this);
        this.getChainId = this.getChainId.bind(this);
        this.enable = this.enable.bind(this);
        this.send = this.send.bind(this);
        this.sendAsync = this.sendAsync.bind(this);
        this.request = this.request.bind(this);
        this.kaikasProvider = provider;
        this.chainId = this.getChainId();
        this.caver = new caver_js_1.default(provider);
        this.kaikasProvider.on('networkChanged', (params) => {
            this.emit('networkChanged', params);
        });
        this.kaikasProvider.on('accountsChanged', (params) => {
            this.emit('accountsChanged', params);
        });
        this._subscriptionManager.events.on('notification', (notification) => {
            this.emit('message', {
                type: notification.method,
                data: notification.params,
            });
        });
    }
    enable() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._addresses.length > 0) {
                return [...this._addresses];
            }
            const res = yield this.kaikasProvider.enable();
            this._addresses = res;
            return res;
        });
    }
    getChainId() {
        const chainIdStr = this.kaikasProvider.networkVersion;
        return chainIdStr;
    }
    get isKaikas() {
        return true;
    }
    get connected() {
        return true;
    }
    supportsSubscriptions() {
        return false;
    }
    disconnect() {
        return true;
    }
    send(requestOrMethod, callbackOrParams) {
        // send<T>(method, params): Promise<T>
        if (typeof requestOrMethod === 'string') {
            const method = requestOrMethod;
            const params = Array.isArray(callbackOrParams)
                ? callbackOrParams
                : callbackOrParams !== undefined
                    ? [callbackOrParams]
                    : [];
            const request = {
                jsonrpc: '2.0',
                id: 0,
                method,
                params,
            };
            return this._sendRequestAsync(request).then((res) => res.result);
        }
        // send(JSONRPCRequest | JSONRPCRequest[], callback): void
        if (typeof callbackOrParams === 'function') {
            const request = requestOrMethod;
            const callback = callbackOrParams;
            return this._sendAsync(request, callback);
        }
        // send(JSONRPCRequest[]): JSONRPCResponse[]
        if (Array.isArray(requestOrMethod)) {
            const requests = requestOrMethod;
            return requests.map((r) => this._sendRequest(r));
        }
        // send(JSONRPCRequest): JSONRPCResponse
        const req = requestOrMethod;
        return this._sendRequest(req);
    }
    sendAsync(request, callback) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof callback !== 'function') {
                throw new Error('callback is required');
            }
            // send(JSONRPCRequest[], callback): void
            if (Array.isArray(request)) {
                const arrayCb = callback;
                this._sendMultipleRequestsAsync(request)
                    .then((responses) => arrayCb(null, responses))
                    .catch((err) => arrayCb(err, null));
                return;
            }
            // send(JSONRPCRequest, callback): void
            const cb = callback;
            return this._sendRequestAsync(request)
                .then((response) => cb(null, response))
                .catch((err) => cb(err, null));
        });
    }
    request(args) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!args || typeof args !== 'object' || Array.isArray(args)) {
                throw eth_rpc_errors_1.ethErrors.rpc.invalidRequest({
                    message: 'Expected a single, non-array, object argument.',
                    data: args,
                });
            }
            const { method, params } = args;
            if (typeof method !== 'string' || method.length === 0) {
                throw eth_rpc_errors_1.ethErrors.rpc.invalidRequest({
                    message: "'args.method' must be a non-empty string.",
                    data: args,
                });
            }
            if (params !== undefined && !Array.isArray(params) && (typeof params !== 'object' || params === null)) {
                throw eth_rpc_errors_1.ethErrors.rpc.invalidRequest({
                    message: "'args.params' must be an object or array if provided.",
                    data: args,
                });
            }
            const newParams = params === undefined ? [] : params;
            // Coinbase Wallet Requests
            const res = yield this._sendRequestAsync({
                method,
                params: newParams,
                jsonrpc: '2.0',
                id: 0,
            });
            return res.result;
        });
    }
    _sendRequest(request) {
        const response = {
            jsonrpc: '2.0',
            id: request.id,
        };
        const { method } = request;
        response.result = this._handleSynchronousMethods(request);
        if (response.result === undefined) {
            throw new Error(`Kaikas Wallet does not support calling ${method} synchronously without ` +
                `a callback. Please provide a callback parameter to call ${method} ` +
                `asynchronously.`);
        }
        return response;
    }
    _sendRequestAsync(request) {
        return new Promise((resolve, reject) => {
            try {
                const syncResult = this._handleSynchronousMethods(request);
                if (syncResult !== undefined) {
                    return resolve({
                        jsonrpc: '2.0',
                        id: request.id,
                        result: syncResult,
                    });
                }
                const subscriptionPromise = this._handleSubscriptionMethods(request);
                if (subscriptionPromise !== undefined) {
                    subscriptionPromise
                        .then((res) => resolve({
                        jsonrpc: '2.0',
                        id: request.id,
                        result: res.result,
                    }))
                        .catch((err) => reject(err));
                    return;
                }
            }
            catch (err) {
                return reject(err);
            }
            this._handleAsynchronousMethods(request)
                .then((res) => res && resolve(Object.assign(Object.assign({}, res), { id: request.id })))
                .catch((err) => reject(err));
        });
    }
    _handleSubscriptionMethods(request) {
        switch (request.method) {
            case JSONRPC_1.JSONRPCMethod.eth_subscribe:
            case JSONRPC_1.JSONRPCMethod.eth_unsubscribe:
                return this._subscriptionManager.handleRequest(request);
        }
        return undefined;
    }
    _sendMultipleRequestsAsync(requests) {
        return Promise.all(requests.map((r) => this._sendRequestAsync(r)));
    }
    _handleSynchronousMethods(request) {
        const { method } = request;
        switch (method) {
            case JSONRPC_1.JSONRPCMethod.eth_accounts:
                return this._eth_accounts();
            case JSONRPC_1.JSONRPCMethod.net_version:
                return this._net_version();
            case JSONRPC_1.JSONRPCMethod.eth_chainId:
                return this._eth_chainId();
            default:
                return undefined;
        }
    }
    _eth_accounts() {
        return [...this._addresses];
    }
    _eth_chainId() {
        return this.getChainId();
    }
    _net_version() {
        return parseInt(this.kaikasProvider.networkVersion, 10);
    }
    _handleAsynchronousMethods(request) {
        return __awaiter(this, void 0, void 0, function* () {
            const { method } = request;
            const params = request.params || [];
            switch (method) {
                case JSONRPC_1.JSONRPCMethod.personal_sign:
                    return this._personal_sign(params);
                case JSONRPC_1.JSONRPCMethod.personal_ecRecover:
                    return this._personal_ecRecover(params);
                case JSONRPC_1.JSONRPCMethod.eth_signTransaction:
                    return this._eth_signTransaction(params);
                case JSONRPC_1.JSONRPCMethod.eth_sendRawTransaction:
                    return this._eth_sendRawTransaction(params);
                case JSONRPC_1.JSONRPCMethod.eth_sendTransaction:
                    return this._eth_sendTransaction(params);
                case JSONRPC_1.JSONRPCMethod.eth_blockNumber:
                    return this._eth_blockNumber(params);
                case JSONRPC_1.JSONRPCMethod.eth_getBlockByNumber:
                    return this._eth_getBlockByNumber(params);
                case JSONRPC_1.JSONRPCMethod.eth_getGasPrice:
                    return this._eth_getGasPrice(params);
                case JSONRPC_1.JSONRPCMethod.wallet_watchAsset:
                    return this._wallet_watchAsset(params);
                case JSONRPC_1.JSONRPCMethod.eth_getTransactionReceipt:
                    return this._eth_getTransactionReceipt(params);
                case JSONRPC_1.JSONRPCMethod.eth_call:
                    return this._eth_call(params);
            }
            return this.kaikasSendAsync(request);
        });
    }
    kaikasSendAsync(request) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                this.kaikasProvider.sendAsync(request, (err, result) => {
                    if (result.result) {
                        resolve(result);
                    }
                    else {
                        reject(err);
                    }
                });
            });
        });
    }
    _eth_call(params) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                this.kaikasProvider.sendAsync({
                    method: 'klay_call',
                    params: [params[0], params[1]],
                }, (err, result) => {
                    if (result.result) {
                        resolve(result);
                    }
                    else {
                        reject(err);
                    }
                });
            });
        });
    }
    _eth_getGasPrice(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.caver.rpc.klay.getGasPrice();
            return { jsonrpc: '2.0', id: 0, result: result };
        });
    }
    _wallet_watchAsset(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const request = (Array.isArray(params) ? params[0] : params);
            console.log('watch asset', params, request);
            if (!request.type) {
                throw eth_rpc_errors_1.ethErrors.rpc.invalidParams({
                    message: 'Type is required',
                });
            }
            if ((request === null || request === void 0 ? void 0 : request.type) !== 'ERC20') {
                throw eth_rpc_errors_1.ethErrors.rpc.invalidParams({
                    message: `Asset of type '${request.type}' is not supported`,
                });
            }
            if (!(request === null || request === void 0 ? void 0 : request.options)) {
                throw eth_rpc_errors_1.ethErrors.rpc.invalidParams({
                    message: 'Options are required',
                });
            }
            if (!(request === null || request === void 0 ? void 0 : request.options.address)) {
                throw eth_rpc_errors_1.ethErrors.rpc.invalidParams({
                    message: 'Address is required',
                });
            }
            const { address, symbol, image, decimals } = request.options;
            const res = yield this.watchAsset(request.type, address, symbol, decimals, image);
            return { jsonrpc: '2.0', id: 0, result: res };
        });
    }
    watchAsset(type, address, symbol, decimals, image) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                this.kaikasProvider.sendAsync({
                    method: 'wallet_watchAsset',
                    params: {
                        type,
                        options: {
                            address,
                            symbol,
                            decimals,
                            image,
                        },
                    },
                }, (err, result) => {
                    if (result.result) {
                        resolve(!!result.result);
                    }
                    else {
                        reject(err);
                    }
                });
            });
        });
    }
    _personal_sign(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const signedMessage = yield this.caver.klay.sign(params[0], params[1]);
            return { jsonrpc: '2.0', id: 0, result: signedMessage };
        });
    }
    _eth_sendTransaction(params) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                // gas(=gasLimit) is required. Sender, receiver, gas, value are required.
                // If gasPrice is undefined, eth_sendTransaction calls eth_gasPrice API before sending tx.
                const res = yield this.caver.klay.sendTransaction(params[0]);
                return { jsonrpc: '2.0', id: 0, result: res.transactionHash };
            }
            catch (err) {
                if (typeof err.message === 'string' && err.message.match(/(denied|rejected)/i)) {
                    throw eth_rpc_errors_1.ethErrors.provider.userRejectedRequest('User denied transaction signature');
                }
                throw err;
            }
        });
    }
    _eth_signTransaction(params) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const res = yield this.caver.klay.signTransaction(params[0]);
                return { jsonrpc: '2.0', id: 0, result: res };
            }
            catch (err) {
                if (typeof err.message === 'string' && err.message.match(/(denied|rejected)/i)) {
                    throw eth_rpc_errors_1.ethErrors.provider.userRejectedRequest('User denied transaction signature');
                }
                throw err;
            }
        });
    }
    _eth_sendRawTransaction(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.caver.klay.sendTransaction({
                senderRawTransaction: params[0],
                feePayer: this.kaikasProvider.selectedAddress,
            });
            return { jsonrpc: '2.0', id: 0, result: res.transactionHash };
        });
    }
    _eth_getTransactionReceipt(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const receipt = yield this.caver.rpc.klay.getTransactionReceipt(params[0]);
            return { jsonrpc: '2.0', id: 0, result: receipt };
        });
    }
    _personal_ecRecover(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const address = yield this.caver.utils.recover(params[0], params[1]);
            return { jsonrpc: '2.0', id: 0, result: address };
        });
    }
    _eth_blockNumber(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const blockNumber = yield this.caver.rpc.klay.getBlockNumber();
            return { jsonrpc: '2.0', id: 0, result: blockNumber };
        });
    }
    _eth_getBlockByNumber(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const block = yield this.caver.rpc.klay.getBlockByNumber(params[0], params[1]);
            return { jsonrpc: '2.0', id: 0, result: block };
        });
    }
}
exports.KaikasWeb3Provider = KaikasWeb3Provider;
